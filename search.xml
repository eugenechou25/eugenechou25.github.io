<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络笔记（旧版）</title>
      <link href="/2019/12/22/note-0/"/>
      <url>/2019/12/22/note-0/</url>
      
        <content type="html"><![CDATA[<p>计算机网络的根本目的：共享</p><p>网络三要素：1. 网络服务      2. 传输媒介        3. 通信协议</p><p>网络功能的特点：</p><ol><li>资源共享</li><li>寻址与差错控制</li><li>路由选择</li><li>会话建立与管理</li><li>异构多重网络之间的通信</li><li>高带宽与多点共享</li><li>消除系统之间的差异与加密</li><li>拥塞控制与负载均衡</li></ol><p>网络的分类：</p><p>按<strong>拓扑结构</strong>、<strong>网络操作系统</strong>、<strong>应用的角度</strong>、<strong>应用的领域</strong>、<strong>数据的交换方式</strong>来划分。</p><p>局域网：</p><p>Local Aera Network,LAN. 一般指规模较小的网络，在地里上局限于较小的范围，通信线路不长，网络的跨度在几公里之内。</p><p>城域网：</p><p>Metropolitan Area Network,MAN. 它的规模较局域网要大许多，城域网通常覆盖一个城市或一个地区。</p><p>广域网：</p><p>Wide Area Network, WAN. 非常大的网，广域网不仅可以将多个局域网城域网连接起来，也可以把世界各地的计算机连接在一起。</p><p>网络计算模型：</p><p>计算机网络的发展经历了多种模式，其模式称之为计算模型。</p><p>计算模型有：</p><ol><li>集中式计算(Centralized      Computing)</li><li>分布式计算(Distributed      Computing)</li><li>协同式计算(Collaborative      Computing)</li><li>客户机/服务器(Client/Server)</li><li>客户机/网络(Client/Network)</li></ol><p>网络的体系架构：</p><p>资源子网：</p><p>主要任务是提供资源共享和获得服务所需的硬件、软件及数据。</p><p>通信子网：</p><p>主要功能是完成对数据的传输、交换以及控制，具体地实现计算机网络资源与服务的传输与交换。</p><p>网络的层次化结构：</p><p>在计算机网络层次化结构中，数据流并不在两个同等层之间直接流动，而是在同一主机上相邻的层之间流动。</p><p><strong>接口</strong>：</p><p>相邻层之间的界面。</p><p>网络服务</p><p>网络服务的方式：1. <strong>集中式网络服务</strong>      2. <strong>分布式网络服务</strong></p><p>决定网络服务的几个因素：</p><ol><li>资源控制策略</li><li>服务器专用性</li><li>网络操作系统</li></ol><p>网络服务内容：</p><ol><li>文件服务</li><li>打印服务</li><li>信息服务</li><li>应用服务</li><li>计算机网络的数据库服务</li></ol><p>主动性是信息服务的最基本特征</p><p>第二章</p><p>OSI模型概要</p><p>OSI模型：(Open System Interconnection Reference Model,OSI) 开放系统互联参考模型</p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ul><p>（自下而上）</p><p>分层协议的特点：</p><ol><li>每一层都建立在其下层之上</li><li>享用下层提供的服务</li><li>为上层提供一定的服务</li><li>屏蔽所提供服务的实现细节</li></ol><p>协议堆栈</p><p>多个协议分别承担不同层次功能所需要完成的任务，各层协议相互协作，构成一个整体，这些互相关联的多个协议构成一个“协议堆栈(Protocol Family)”或者“协议族(Protocol Suite)”。</p><p><strong>对等实体</strong>：</p><p>Peer, 不同系统中的相同层实体。</p><p>OSI模型分层分层原则</p><ol><li><p>着眼于协议的标准化</p></li><li><p>有利于优化相邻层次的接口</p></li><li><p>按功能抽象分类层次</p></li><li><p>层次描述的完整性</p></li><li><p>层次不能太多，不能太少</p></li></ol><p>OSI模型术语</p><ol><li>服务</li></ol><p>第N层实体通过完成第N层的功能，向第N+1层提供服务，这种服务被称为第N层服务，第N层实体需要或者要求其他第N层实体的合作，第N层协议对第N+1层实体是透明的。</p><ol><li>连接</li></ol><p>为了在两个或多个第N+1层实体之间交换信息，需要在第N层利用第N 层协议为这些第N+1层实体建立一个互相的联系，这种联系称之为第N层的连接，第N层连接的两端称为第N层的<strong>连接端点</strong>(Connection End Point)。</p><ol><li>中继</li></ol><p>公共数据网中的<strong>存储转发功能</strong>就是中继的具体表现</p><ol><li><p>连接服务方式</p></li><li><ul><li>面向连接服务方式</li></ul></li></ol><p>每一次完整的数据传输都必须经过建立连接、使用连接、释放连接3三个过程，其特点是收发数据内容一致、顺序一致、能及时纠错和调整流量</p><ul><li>无连接服务方式</li></ul><p>类似于邮政系统的服务模式，数据的传输用分组的方式，每一个数据带有完整的目标地址，独立传送，不能保证发送的顺序一致，但具有纠错和流量控制能力。</p><ol><li>数据单元</li></ol><p>数据传输的<strong>最小单位</strong>称为<strong>数据单元</strong></p><ul><li><strong>协议数据单元</strong></li></ul><p>（Protocol Data Unit,<strong>PDU</strong>)，为实现该层协议所交换的数据单元，将第N层的协议数据单元记为第N层PDU。PDU由两部分组成：第N层用户数据和第N层协议控制信息（Protocol Control Information,PCI）</p><ul><li><strong>接口数据单元</strong></li></ul><p>（Interface Data Unit,<strong>IDU</strong>）经过相邻层<strong>接口</strong>的数据单元，一个协议数据单元PDU加上适当的接口控制信息(Interface Control Information,ICI）构成接口数据单元。</p><ul><li><strong>服务数据单元</strong></li></ul><p>（Service Data Unit,<strong>SDU</strong>）完成服务用户所请求的功能需要的数据单元，第N层服务数据单元就是第N层服务所要传送的逻辑数据单元。</p><p>OSI物理层</p><p>核心</p><p>协调“位”的传输规则。</p><p>目的</p><p>实现“位”的快速和正确的传输</p><p>网络连接类型</p><ul><li>点到点的连接</li><li>多点连接</li></ul><p><strong>物理拓扑结构</strong></p><p>概念：是以传输媒介构成的计算机网络的结构或数据信号所传输的物理路径，通俗的讲，网络设备之间的连接方式称为网络的物理拓扑结构。</p><ol><li><strong>总线型拓扑结构</strong></li></ol><p>通常用一根长电缆把设备串联起来，这条电缆叫主干。所采用的传输媒介为同轴电缆，主干两端安装终端适配器，使信号通过所有设备后从主干上消失。</p><ul><li>安装难易程度：较容易</li><li>再配置难易程度：相对简单，但是有一定的限制，总线长度超过规范或设备数量超标时常常需要修改主干。</li><li>维护难易程度：相对困难，排查故障困难</li><li>媒介故障对网络影响程度：大</li></ul><p>优点：</p><p>使用成熟确定的标准，安装较容易，使用电缆相对较少。</p><p>劣势：</p><p>再配置难，排除故障困难，媒介出现故障网络随即瘫痪，通信带宽有限。</p><ol><li>环形拓扑结构</li></ol><p>网络设备以串联的方式连接并构成一个封闭的环状。</p><ul><li>安装难易程度：比较简单，但对环上的设备数量有一定限制。</li><li>再配置难易程度：环的最大长度和环上设备数有限制，再配置困难。</li><li>维护难易程度：可维护性大于总线型。</li><li>媒介故障影响程度：单环影响程度大，双环影响程度相对较小。</li></ul><p>优势：</p><p>电缆故障容易排除；双环结构容错能力强。</p><p>劣势：</p><p>安装配置较难；通信带宽有限。</p><ol><li>星型拓扑结构</li></ol><p>每个星型拓扑结构均拥有一个中心设备，其他所有网络设备均以<strong>点到点</strong>的方式连接到该中心设备。</p><ul><li>安装难易程度：较前面两个来说，相对较困难，但是现有的技术使得安装较容易</li><li>再配置难易程度：较容易</li><li>维护难易程度：较容易</li><li>媒介故障影响程度：影响较小</li></ul><p>优势：</p><p>高速网络协议均支持星型拓扑结构；再配置容易；排除故障容易；媒介故障容易排除。</p><p>劣势：</p><p>所用的电缆多。</p><ol><li>网状拓扑结构</li></ol><p>每台设备之间相互都有点到点的连接。</p><ul><li>安装难易程度：很难</li><li>再配置难易程度：很难</li><li>维护难易程度：易于维护，可以容易确定故障所在。</li><li>媒介故障影响程度：较小</li></ul><p>优势：</p><p>故障容易排除；故障点容易隔离；有很高的容错能力</p><p>劣势：</p><p>系统的安装和再配置特别困难。</p><p><strong>数字信令</strong></p><p>电脉冲或电磁波信号及其编码方式称为信令。</p><p>优势：</p><p>所采用的相应设备较简单、廉价；受噪声干扰影响小</p><p>劣势：</p><p>在可比距离内，数字信号比模拟信号的衰减大。</p><p>模拟信令</p><p>模拟信令的产生是电路中的正弦电磁波形成的。</p><p>定义策略：</p><p>当前状态：</p><p>FSK（Frequency-Shift-Keying）</p><p>频移键控采用信号的两种或多种频率来进行二进制数据的编码。</p><p>ASK（Amplitude-Shift-Keying）</p><p>幅移键控才用信号的两个或多个电平值（正弦波的振幅）进行二进制的数据编码。</p><p>状态改变：</p><p>PSK（Phase-Shift-Keying）</p><p>相移键控利用的是模拟信号正弦波的相位改变过程，二进制数据可被编码到带有相位改变的模拟信号上。</p><p>位同步</p><ol><li>异步位系统</li></ol><p>异步位系统使用间歇信号来传送每一个位，当无数据传输时，在传输媒介信道上就无信号，当有数据传送时，接受设备用一个硬件时钟确定本方应该何时测量信号。</p><ol><li>同步位系统</li></ol><p>同步位系统提供一个时钟，用于协调发送方和接收方的设备内部时钟，时二者设备的时钟同步，从而使接收双方能正确计时，正确测量媒介上的信号。</p><p>物理信道</p><p>信道（Channel）使传输媒介整个电磁频谱带宽的一部分。一个信道使通过对传输媒介所拥有的电磁频谱进行划分而得到的。</p><p>基带（BaseBand）系统</p><p>基带系统用传输媒介所能提供的整个容量传输一个信号。计算机网络就是一个标准的多点连接基带系统。</p><p>宽带（BroadBand）系统</p><p>宽带系统白传输媒介的容量划分位多个信道，分别传输不同的信号。区别：基带系统中只有一种频率的信号在传输，宽带系统同时可以有多个频率的信号在传输。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之\&lt;script&gt;</title>
      <link href="/2019/12/21/javascript-0/"/>
      <url>/2019/12/21/javascript-0/</url>
      
        <content type="html"><![CDATA[<h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="<script>元素"></a>&lt;script&gt;元素</h3><p>如果把网页比作一个人，那么HTML就是人的骨架，CSS就是人的服饰，而javascript就是肌肉和神经，虽然这样的比喻不太适合，但是多多少少两者都有点类似。要想在HTML中使用JavaScript，就需要使用&lt;script&gt;元素。平时我们使用JavaScript都是使用类似于<code>&lt;script type="text/javascript" src="xxx/xxx.js"&gt;</code>，其实正式的HTML规范中，&lt;script&gt;元素还有其他属性。</p><h6 id="0-async属性"><a href="#0-async属性" class="headerlink" title="#0 async属性"></a>#0 <code>async</code>属性</h6><p>属于可选属性，异步的意思，表示应该立即下载脚本，但不妨碍其他操作，比如下载其他资源或等待加载其他脚本，这个属性只有在使用外部脚本的时候有用，即不是内嵌脚本的时候。</p><h6 id="1-charset属性"><a href="#1-charset属性" class="headerlink" title="#1 charset属性"></a>#1 <code>charset</code>属性</h6><p>属于可选属性，表示通过<code>src</code>引入的外部文件的字符集。</p><h6 id="2-defer属性"><a href="#2-defer属性" class="headerlink" title="# 2 defer属性"></a># 2 <code>defer</code>属性</h6><p>可选属性，表示脚本可以延迟到整个文档解析、显示完成之后再之形，同样的，只对外部导入的脚本有效。</p><h6 id="3-src属性"><a href="#3-src属性" class="headerlink" title="# 3 src属性"></a># 3 <code>src</code>属性</h6><p>可选的，当使用嵌入脚本代码的就不用这个属性，表示要执行的外部文件。</p><h6 id="4-type属性"><a href="#4-type属性" class="headerlink" title="# 4 type属性"></a># 4 <code>type</code>属性</h6><p>必选，表示编码代码使用的脚本语言的内容类型。</p><h4 id="lt-script-gt-的位置"><a href="#lt-script-gt-的位置" class="headerlink" title="<script> 的位置"></a>&lt;script&gt; 的位置</h4><p>通常的做法都是将<code>&lt;script&gt;</code>标签内容放在<code>&lt;head&gt;</code>元素中，这就意味着只有等到相关的脚本和文件加载完成之后，页面才开始渲染，如果脚本文件过大，可能导致页面一片空白，为了避免这个问题，规范的Web程序应该将<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前面，如下面这样的：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面与向对象</title>
      <link href="/2019/12/20/java/"/>
      <url>/2019/12/20/java/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h4><p>在面向对象编程中把相似的对象划归为一个类，比如我是学生，你也是学生，他也是学生，我们都在学校上学，都有学号、班级等共同属性，可以把我们归为一个学生类。在开发中呢，类还是一个模板，它定义了一个特定种类的所有对象的状态（也叫属性、变量）和行为（方法）。</p><p>类是创建对象的的模板，对象是类的实例。</p><p>从程序设计的角度看，类是面向对象程序设计中最基本的程序单元，类实质上定义的是一种数据类型，这种数据类型就是对象类型，所以我们可以用类名称来声明对象变量。，声明对象变量之后，还不能使用对象，必须用运算符<code>new</code>来创建对象实体，才可以使用对象。</p><h4 id="Java中类的定义"><a href="#Java中类的定义" class="headerlink" title="Java中类的定义"></a>Java中类的定义</h4><p>类的定义样板大概如下(伪代码)</p><pre class="line-numbers language-java"><code class="language-java">修饰符 <span class="token keyword">class</span> 类名 <span class="token punctuation">[</span><span class="token keyword">extends</span> 父类名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">implements</span> 接口名<span class="token punctuation">]</span><span class="token punctuation">{</span>    类型 成员变量<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    修饰符 类型 方法名<span class="token punctuation">(</span>类型 参数<span class="token number">1</span><span class="token punctuation">,</span>类型 参数<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        类型 局部变量<span class="token punctuation">;</span>        方法体<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[]中的为可选，修饰符修饰的是访问控制权限，比如public表示公有的，子类可以访问的。</p><p>上面伪代码没有写出来的其实还有一个很重要的一部分——类的构造函数，构造函数是类的一个特殊方法，它负责初始化类的成员变量，完成类对象的初始化工作，为使用类的对象做准备，与其他方法不同的是构造方法没有返回值而且必须与类名相同，调用方法也和普通方法不一样，必须通过new关键字来调用，调用形式如<code>类名 对象名 = new 构造方法名()</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客开通啦</title>
      <link href="/2019/12/16/my-blog/"/>
      <url>/2019/12/16/my-blog/</url>
      
        <content type="html"><![CDATA[<h4 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h4><p>其实之前早就有创一个自己博客的想法了，一直没有付诸行动，现在稍微了解了前端知识，跟着教程一步一步把这个博客搭建出来，后续还会继续优化。</p><h4 id="会写些什么"><a href="#会写些什么" class="headerlink" title="会写些什么"></a>会写些什么</h4><p>emmm……主要是分享自己的收获，以及所感所感所想。</p><p>如果有错误，请各位大佬指出🤣。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
